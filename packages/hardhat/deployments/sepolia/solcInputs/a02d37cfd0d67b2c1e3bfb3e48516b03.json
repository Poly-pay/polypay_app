{
  "language": "Solidity",
  "sources": {
    "contracts/MetaMultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// import \"poseidon-solidity/PoseidonT3.sol\";\n\ninterface IVerifyProofAggregation {\n    function verifyProofAggregation(\n        uint256 _domainId,\n        uint256 _aggregationId,\n        bytes32 _leaf,\n        bytes32[] calldata _merklePath,\n        uint256 _leafCount,\n        uint256 _index\n    ) external view returns (bool);\n}\n\ncontract MetaMultiSigWallet {\n    // ============ Constants ============\n    bytes32 public constant PROVING_SYSTEM_ID = keccak256(abi.encodePacked(\"ultraplonk\"));\n    bytes32 public constant VERSION_HASH = sha256(abi.encodePacked(\"\"));\n    uint256 public constant MAX_SIGNERS = 16;\n\n    // ============ Events ============\n    event Deposit(address indexed sender, uint256 amount, uint256 balance);\n    event TransactionProposed(uint256 indexed txId, address to, uint256 value, bytes data);\n    event SignatureSubmitted(uint256 indexed txId, uint256 nullifier);\n    event TransactionExecuted(uint256 indexed txId, address to, uint256 value, bytes data, bytes result);\n    event Owner(uint256 indexed commitment, bool isAdded);\n\n    // ============ Structs ============\n    struct ZkProof {\n        uint256 nullifier;\n        uint256 aggregationId;\n        uint256 domainId;\n        bytes32[] zkMerklePath;\n        uint256 leafCount;\n        uint256 index;\n    }\n\n    struct PendingTx {\n        address to;\n        uint256 value;\n        bytes data;\n        uint256 requiredApprovalsWhenExecuted;\n        uint256 validSignatures;\n        bool executed;\n    }\n\n    // ============ State ============\n    address public immutable poseidon2Address;\n    address public immutable zkvContract;\n    bytes32 public immutable vkHash;\n    uint256 public chainId;\n    uint256 public nonce;\n    uint256 public signaturesRequired;\n\n    // Signer management\n    uint256[] public commitments;\n    uint256 public merkleRoot;\n\n    // Transaction management\n    mapping(uint256 => PendingTx) public pendingTxs;\n    mapping(uint256 => bool) public usedNullifiers;\n\n    // ============ Constructor ============\n    constructor(\n        address _poseidon2Address,\n        address _zkvContract,\n        bytes32 _vkHash,\n        uint256 _chainId,\n        uint256[] memory _initialCommitments,\n        uint256 _signaturesRequired\n    ) {\n        require(_zkvContract != address(0), \"Invalid zkv address\");\n        require(_signaturesRequired > 0, \"Must be non-zero sigs required\");\n        require(_initialCommitments.length > 0, \"Need at least 1 signer\");\n        require(_signaturesRequired <= _initialCommitments.length, \"Sigs required too high\");\n\n        poseidon2Address = _poseidon2Address;\n        zkvContract = _zkvContract;\n        vkHash = _vkHash;\n        chainId = _chainId;\n        signaturesRequired = _signaturesRequired;\n\n        for (uint256 i = 0; i < _initialCommitments.length; i++) {\n            require(_initialCommitments[i] != 0, \"Invalid commitment\");\n            commitments.push(_initialCommitments[i]);\n            emit Owner(_initialCommitments[i], true);\n        }\n\n        _rebuildMerkleRoot();\n    }\n\n    // ============ Modifiers ============\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Not Self\");\n        _;\n    }\n\n    // ============ Transaction Flow ============\n    function proposeTx(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        ZkProof calldata proof\n    ) external returns (uint256 txId) {\n        // Use current nonce as txId\n        txId = nonce;\n\n        // Create pending tx first (needed for getTxHash)\n        pendingTxs[txId] = PendingTx({\n            to: to,\n            value: value,\n            data: data,\n            requiredApprovalsWhenExecuted: signaturesRequired,\n            validSignatures: 0,\n            executed: false\n        });\n\n        // Check nullifier not used\n        require(!usedNullifiers[proof.nullifier], \"Nullifier already used\");\n\n        // Verify ZK proof\n        bytes32 txHash = getTxHashFromTxid(txId);\n        require(_verifyProof(txHash, proof), \"Invalid proof\");\n\n        // Update state\n        usedNullifiers[proof.nullifier] = true;\n        pendingTxs[txId].validSignatures = 1;\n        nonce++;\n\n        emit TransactionProposed(txId, to, value, data);\n        emit SignatureSubmitted(txId, proof.nullifier);\n    }\n\n    function submitSignature(uint256 txId, ZkProof calldata proof) external {\n        PendingTx storage ptx = pendingTxs[txId];\n\n        // Checks\n        require(ptx.to != address(0), \"Tx not exist\");\n        require(!ptx.executed, \"Tx already executed\");\n        require(!usedNullifiers[proof.nullifier], \"Nullifier already used\");\n\n        // Verify ZK proof\n        bytes32 txHash = getTxHashFromTxid(txId);\n        require(_verifyProof(txHash, proof), \"Invalid proof\");\n\n        // Update state\n        usedNullifiers[proof.nullifier] = true;\n        ptx.validSignatures++;\n\n        emit SignatureSubmitted(txId, proof.nullifier);\n    }\n\n    function executeTransaction(uint256 txId) external returns (bytes memory) {\n        PendingTx storage ptx = pendingTxs[txId];\n\n        // Checks\n        require(ptx.to != address(0), \"Tx not exist\");\n        require(!ptx.executed, \"Tx already executed\");\n        require(ptx.validSignatures >= signaturesRequired, \"Not enough signatures\");\n\n        // Execute\n        ptx.executed = true;\n        ptx.requiredApprovalsWhenExecuted = signaturesRequired;\n\n        (bool success, bytes memory result) = ptx.to.call{ value: ptx.value }(ptx.data);\n        require(success, \"Tx failed\");\n\n        emit TransactionExecuted(txId, ptx.to, ptx.value, ptx.data, result);\n        return result;\n    }\n\n    // ============ Signer Management ============\n    function addSigner(uint256 newCommitment, uint256 newSigRequired) public onlySelf {\n        require(newCommitment != 0, \"Invalid commitment\");\n        require(commitments.length < MAX_SIGNERS, \"Max signers reached\");\n        require(newSigRequired > 0, \"Must be non-zero sigs required\");\n        require(newSigRequired <= commitments.length + 1, \"Sigs required too high\");\n\n        // Check duplicate\n        for (uint256 i = 0; i < commitments.length; i++) {\n            require(commitments[i] != newCommitment, \"Commitment exists\");\n        }\n\n        commitments.push(newCommitment);\n        signaturesRequired = newSigRequired;\n        _rebuildMerkleRoot();\n\n        emit Owner(newCommitment, true);\n    }\n\n    function removeSigner(uint256 commitment, uint256 newSigRequired) public onlySelf {\n        require(commitments.length > 1, \"Cannot remove last signer\");\n        require(newSigRequired > 0, \"Must be non-zero sigs required\");\n        require(newSigRequired <= commitments.length - 1, \"Sigs required too high\");\n\n        // Find and remove\n        bool found = false;\n        for (uint256 i = 0; i < commitments.length; i++) {\n            if (commitments[i] == commitment) {\n                commitments[i] = commitments[commitments.length - 1];\n                commitments.pop();\n                found = true;\n                break;\n            }\n        }\n        require(found, \"Commitment not found\");\n\n        signaturesRequired = newSigRequired;\n        _rebuildMerkleRoot();\n\n        emit Owner(commitment, false);\n    }\n\n    function updateSignaturesRequired(uint256 newSigRequired) public onlySelf {\n        require(newSigRequired > 0, \"Must be non-zero sigs required\");\n        require(newSigRequired <= commitments.length, \"Sigs required too high\");\n        signaturesRequired = newSigRequired;\n    }\n\n    // ============ View Functions ============\n    function getTxHashFromTxid(uint256 txId) public view returns (bytes32) {\n        PendingTx storage ptx = pendingTxs[txId];\n        return keccak256(abi.encodePacked(address(this), chainId, txId, ptx.to, ptx.value, ptx.data));\n    }\n\n    function getTransactionHash(\n        uint256 _nonce,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) public view returns (bytes32) {\n        return keccak256(abi.encodePacked(address(this), chainId, _nonce, to, value, data));\n    }\n\n    function getCommitments() external view returns (uint256[] memory) {\n        return commitments;\n    }\n\n    function getSignersCount() external view returns (uint256) {\n        return commitments.length;\n    }\n\n    function getPendingTx(\n        uint256 txId\n    ) external view returns (address to, uint256 value, bytes memory data, uint256 validSignatures, uint256 requiredApprovalsWhenExecuted, bool executed) {\n        PendingTx storage ptx = pendingTxs[txId];\n        return (ptx.to, ptx.value, ptx.data, ptx.validSignatures, ptx.requiredApprovalsWhenExecuted, ptx.executed);\n    }\n\n    // ============ Internal Functions ============\n    function _verifyProof(bytes32 txHash, ZkProof calldata proof) internal view returns (bool) {\n        // Compute txHashCommitment = poseidon(txHash)\n        uint256 txHashCommitment = poseidon2Hash1(uint256(txHash)); \n\n        // Encode public inputs (must match circuit order)\n        bytes memory encodedInputs = abi.encodePacked(txHashCommitment, merkleRoot, proof.nullifier);\n\n        // Calculate leaf for zkVerify\n        bytes32 leaf = keccak256(abi.encodePacked(PROVING_SYSTEM_ID, vkHash, VERSION_HASH, keccak256(encodedInputs)));\n\n        // Verify with zkVerify\n        return\n            IVerifyProofAggregation(zkvContract).verifyProofAggregation(\n                proof.domainId,\n                proof.aggregationId,\n                leaf,\n                proof.zkMerklePath,\n                proof.leafCount,\n                proof.index\n            );\n    }\n\n    function _rebuildMerkleRoot() internal {\n        uint256[] memory leaves = new uint256[](MAX_SIGNERS);\n\n        // Copy commitments, rest are 0\n        for (uint256 i = 0; i < commitments.length; i++) {\n            leaves[i] = commitments[i];\n        }\n\n        // Build merkle tree bottom-up\n        uint256 n = MAX_SIGNERS;\n        while (n > 1) {\n            for (uint256 i = 0; i < n / 2; i++) {\n                leaves[i] = poseidon2Hash2(leaves[2 * i], leaves[2 * i + 1]);\n            }\n            n = n / 2;\n        }\n\n        merkleRoot = leaves[0];\n    }\n\n    // ============ Receive ETH ============\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n\n    // always return hash with 3 inputs, padding with 0s if needed\n    // cause we use Yul library with fixed 3-input hash function\n    // Yul library is more gas efficient\n    function poseidon2Hash1(uint256 a) public view returns (uint256) {\n        (bool success, bytes memory result) = poseidon2Address.staticcall(abi.encode(a, uint256(0), uint256(0)));\n        require(success, \"Poseidon2 hash failed\");\n        return abi.decode(result, (uint256));\n    }\n\n    function poseidon2Hash2(uint256 a, uint256 b) public view returns (uint256) {\n        (bool success, bytes memory result) = poseidon2Address.staticcall(abi.encode(a, b, uint256(0)));\n        require(success, \"Poseidon2 hash failed\");\n        return abi.decode(result, (uint256));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}